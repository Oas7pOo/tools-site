---
layout: default
title: 文本转摩斯密码 - 冰兔的工具站
header_title: 文本转摩斯密码
header_description: 将文本输入文本框生成摩斯密码文件与音频，以及将音频或摩斯密码转回文本文件。
---

<h2>文本转摩斯密码工具</h2>
<div class="container">
    <label for="plaintext">请输入内容（中文将转成拼音，英文数字标点直接处理，空格→/）：</label>
    <textarea id="plaintext" rows="4" style="width: 100%;"></textarea>

    <button onclick="convertToMorse()" class="disable-on-click" >生成摩斯文本文件</button>
    <button onclick="downloadMorseAudio()" class="disable-on-click" >生成并下载摩斯音频</button>
</div>

<hr>
<h2>摩斯编码解密</h2>
<div class="container">
    <p>可直接粘贴摩斯码（空格以<code>/</code>分隔），或选择上传音频：</p>

    <!-- 文本解密 -->
    <label for="morseText">粘贴摩斯码 (空格=斜杠/，字符间空格分隔):</label>
    <textarea id="morseText" rows="3" style="width:100%;"></textarea>
    <button onclick="decodeMorseText()" class="disable-on-click" >解密回拼音/英文/数字</button>
    <p id="decodedResult" style="margin-top: 1em; font-weight: bold;"></p>

    <!-- 音频解密 -->
    <label for="morseAudioFile">或上传摩斯音频文件：</label>
    <input type="file" id="morseAudioFile" accept=".wav,.mp3,audio/wav,audio/mp3,audio/*" />
    <div style="margin: 10px 0;">
        <p>音频解析参数：</p>
        <label>检测敏感度 (0.1-1.0): <input type="range" id="sensitivity" min="0.1" max="1.0" step="0.1" value="0.2"></label>
        <span id="sensitivityValue">0.2</span>
    </div>
    <button onclick="decodeMorseAudio()" class="disable-on-click" >解析音频文件</button>
    <p id="audioDecodeResult" style="margin-top: 1em; font-weight: bold;"></p>
</div>


<script src="../js/pinyin_data.js"></script>
<script src="../js/pinyin_processor.js"></script>
<script>
/***************************************************
 * 1) 汉字 → 拼音
 ***************************************************/
    // 使用全局变量代替import，确保HTML中的onclick事件能访问到函数
    const pinyinConverter = new window.PinyinConverter();

    function convertChineseToPinyin(str) {
        return pinyinConverter.convert(str)
            .toLowerCase() // 统一转小写
            .replace(/\s+/g, ' '); // 标准化空格
    }

/***************************************************
 * 2) 拼音/英文/数字/标点 → 摩斯码
 *    此处空格 => "/"
 ***************************************************/
const morseMap = {
  'A': '.-',    'B': '-...',  'C': '-.-.',  'D': '-..',
  'E': '.',     'F': '..-.',  'G': '--.',   'H': '....',
  'I': '..',    'J': '.---',  'K': '-.-',   'L': '.-..',
  'M': '--',    'N': '-.',    'O': '---',   'P': '.--.',
  'Q': '--.-',  'R': '.-.',   'S': '...',   'T': '-',
  'U': '..-',   'V': '...-',  'W': '.--',   'X': '-..-',
  'Y': '-.--',  'Z': '--..',

  '0': '-----', '1': '.----', '2': '..---', '3': '...--',
  '4': '....-', '5': '.....', '6': '-....', '7': '--...',
  '8': '---..', '9': '----.',

  '.': '.-.-.-',  ',': '--..--',  '?': '..--..',  '!': '-.-.--',
  ':': '---...',  ';': '-.-.-.',  '"': '.-..-.',  "'": '.----.',
  '/': '-..-.',   '(': '-.--.',   ')': '-.--.-',  '&': '.-...',
  '-': '-....-',  '_': '..--.-',  '=': '-...-',   '+': '.-.-.',
  '@': '.--.-.',  '$': '...-..-'
};

function stringToMorse(str) {
  const result = [];
  for (let ch of str) {
    if (ch === ' ') {
      // 空格 => '/'
      result.push('/');
      continue;
    }
    const upperC = ch.toUpperCase();
    if (morseMap[upperC]) {
      result.push(morseMap[upperC]);
    }
    else if (/^[A-Z0-9]$/.test(upperC)) {
      // 若是英数字但没映射上 => '?'
      result.push('?');
    }
    else {
      // 其它字符(如拼音的 'n','i') => 再做拆分或用 '?'
      // 此处简化：一个字符 => 一个 '?'
      result.push('?');
    }
  }
  // 用空格分隔不同字符的摩斯
  return result.join(' ');
}

/***************************************************
 * 3) 将用户输入文本 -> 拼音 -> 摩斯，下载txt
 ***************************************************/
// 将函数暴露到全局window对象，使其可以被HTML中的onclick事件调用
window.convertToMorse = function() {
    const input = document.getElementById('plaintext').value.trim();
    if (!input) {
        alert("请输入要转换的文本");
        return;
    }
    console.log("输入文本:", input);
    const pinyinStr = convertChineseToPinyin(input);
    console.log("转换后的拼音:", pinyinStr);
    const morseStr = stringToMorse(pinyinStr);
    console.log("生成的摩斯码:", morseStr);
    
    const blob = new Blob([morseStr], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `morse_${Date.now()}.txt`;
    a.click();
    URL.revokeObjectURL(url);
}



/***************************************************
 * 4) 生成摩斯音频(空格 => "/" => 更长静音)
 ***************************************************/
// 将函数暴露到全局window对象
window.downloadMorseAudio = async function() {
  const input = document.getElementById('plaintext').value.trim();
  if (!input) {
    alert("请输入要转换的文本");
    return;
  }
  const pinyinStr = convertChineseToPinyin(input);
  const morseStr = stringToMorse(pinyinStr);

  // 拆分成字符(用空格分隔). '.' => 短哔, '-' => 长哔, 其余 => '?'
  // 如果遇到 '/', 代表空格 => 额外长静音
  const context = new (window.AudioContext || window.webkitAudioContext)();

  const dotDur = 0.1;    // 点时长
  const dashDur = 0.3;   // 横时长
  const gapSym = 0.1;    // 同字符内符号间隔
  const gapChar = 0.2;   // 字符间间隔
  const gapSpace = 0.6;  // 空格(“/”)的静音

  const tokens = morseStr.split(' ');

  let totalTime = 0;
  for (let t of tokens) {
    if (t === '/') {
      // 空格 => 仅用更长静音
      totalTime += gapSpace;
      continue;
    }
    // 普通字符
    for (let ch of t) {
      totalTime += (ch === '.') ? dotDur : (ch === '-' ? dashDur : dotDur);
      totalTime += gapSym;
    }
    totalTime += gapChar;
  }

  const sampleRate = context.sampleRate;
  const buffer = context.createBuffer(1, sampleRate * totalTime, sampleRate);
  const channelData = buffer.getChannelData(0);

  let currentSample = 0;
  function writeBeep(durSec, volume=0.3) {
    const length = Math.floor(durSec * sampleRate);
    const freq = 600; // 600Hz
    for (let i = 0; i < length; i++) {
      channelData[currentSample++] = volume * Math.sin(2*Math.PI * freq * (i/sampleRate));
    }
  }
  function writeSilence(durSec) {
    const length = Math.floor(durSec * sampleRate);
    for (let i=0; i<length; i++){
      channelData[currentSample++] = 0;
    }
  }

  // 生成波形
  for (let t of tokens) {
    if (t === '/') {
      // 空格 => 更长静音
      writeSilence(gapSpace);
      continue;
    }
    // 普通字符
    for (let ch of t) {
      if (ch === '.') {
        writeBeep(dotDur);
        writeSilence(gapSym);
      } else if (ch === '-') {
        writeBeep(dashDur);
        writeSilence(gapSym);
      } else {
        // '?'
        writeBeep(dotDur, 0);
        writeSilence(gapSym);
      }
    }
    writeSilence(gapChar);
  }

  // 封装 WAV
  const wavData = encodeWAV(buffer, sampleRate);
  const blob = new Blob([wavData], { type: 'audio/wav' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `morse_audio_${Date.now()}.wav`;
  a.click();
  URL.revokeObjectURL(url);
}

function encodeWAV(buffer, sampleRate=44100) {
  const channelData = buffer.getChannelData(0);
  const numFrames = channelData.length;
  const numChannels = 1;
  const bitsPerSample = 16;

  const byteRate = (sampleRate * numChannels * bitsPerSample) / 8;
  const blockAlign = (numChannels * bitsPerSample) / 8;
  const dataSize = numFrames * numChannels * (bitsPerSample/8);
  const bufferSize = 44 + dataSize;
  const wavBuffer = new ArrayBuffer(bufferSize);
  const view = new DataView(wavBuffer);

  let offset = 0;
  writeString(view, offset, 'RIFF'); offset+=4;
  view.setUint32(offset, 36+dataSize, true); offset+=4;
  writeString(view, offset, 'WAVE'); offset+=4;

  writeString(view, offset, 'fmt '); offset+=4;
  view.setUint32(offset, 16, true); offset+=4;
  view.setUint16(offset, 1, true); offset+=2;
  view.setUint16(offset, numChannels, true); offset+=2;
  view.setUint32(offset, sampleRate, true); offset+=4;
  view.setUint32(offset, byteRate, true); offset+=4;
  view.setUint16(offset, blockAlign, true); offset+=2;
  view.setUint16(offset, bitsPerSample, true); offset+=2;

  writeString(view, offset, 'data'); offset+=4;
  view.setUint32(offset, dataSize, true); offset+=4;

  for (let i=0; i<channelData.length; i++){
    const s = Math.max(-1, Math.min(1, channelData[i]));
    const val = s<0 ? s*0x8000 : s*0x7FFF;
    view.setInt16(offset, val, true);
    offset+=2;
  }

  return wavBuffer;

  function writeString(dv, pos, str) {
    for (let i=0; i<str.length; i++){
      dv.setUint8(pos+i, str.charCodeAt(i));
    }
  }
}

/***************************************************
 * 5) 摩斯解密：若遇 "/" 则还原为空格
 ***************************************************/
const morseReverseMap = {};
for (let c in morseMap) {
  morseReverseMap[morseMap[c]] = c; // ".-" => "A"
}

// 将函数暴露到全局window对象
window.decodeMorseText = function() {
  const input = document.getElementById('morseText').value.trim();
  if (!input) {
    alert("请粘贴摩斯码文本");
    return;
  }
  // 以空格分隔 => ['-.--','---','..-','/',...]
  const tokens = input.split(/\s+/);
  let result = "";
  for (let t of tokens) {
    if (t === '/') {
      // 斜杠代表空格
      result += ' ';
    } else if (morseReverseMap[t]) {
      result += morseReverseMap[t];
    } else {
      // 若不存在映射，则用 "?" 占位
      result += '?';
    }
  }
  document.getElementById('decodedResult').textContent = "解码结果: " + result;
}

/***************************************************
 * 6) 摩斯音频解析功能
 ***************************************************/
// 将函数暴露到全局window对象
window.decodeMorseAudio = async function() {
  const fileInput = document.getElementById('morseAudioFile');
  const resultEl = document.getElementById('audioDecodeResult');
  if (!fileInput.files.length) {
    alert("请选择音频文件");
    return;
  }
  resultEl.textContent = "正在分析音频，请稍候...";
  try {
    const file = fileInput.files[0];
    const arrayBuf = await file.arrayBuffer();
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const audioBuf = await audioCtx.decodeAudioData(arrayBuf);

    // 获取主声道数据
    const data = audioBuf.getChannelData(0);
    const sampleRate = audioBuf.sampleRate;

    // 1. 能量检测优化：使用RMS计算和汉宁窗平滑
    const windowSize = Math.floor(0.01 * sampleRate); // 10ms
    let env = [];
    
    // 创建汉宁窗用于平滑
    const hanningWindow = new Float32Array(windowSize);
    for (let i = 0; i < windowSize; i++) {
      hanningWindow[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (windowSize - 1)));
    }
    
    for (let i = 0; i < data.length; i += windowSize) {
      let sumSq = 0;
      let count = 0;
      for (let j = 0; j < windowSize && i + j < data.length; j++) {
        const weightedSample = data[i + j] * hanningWindow[j];
        sumSq += weightedSample * weightedSample;
        count++;
      }
      // 计算RMS (均方根) 作为能量指标
      env.push(Math.sqrt(sumSq / count));
    }

    // 2. 自适应阈值检测，加入用户可调节的敏感度参数
    const sensitivity = parseFloat(document.getElementById('sensitivity').value) || 0.2;
    const maxEnv = Math.max(...env);
    const threshold = maxEnv * sensitivity;
    let isBeep = env.map(v => v > threshold ? 1 : 0);

    // 3. 按有声/静音分组，统计每段长度（以10ms为单位）
    let segs = [];
    let cur = isBeep[0], len = 1;
    for (let i = 1; i < isBeep.length; i++) {
      if (isBeep[i] === cur) {
        len++;
      } else {
        segs.push({type: cur ? 'beep' : 'silence', len});
        cur = isBeep[i]; len = 1;
      }
    }
    segs.push({type: cur ? 'beep' : 'silence', len});

    // 4. 改进的摩尔斯电码标准时间间隔算法
    // 统计所有 beep 段/静音段的时长
    const beepLens = segs.filter(s => s.type === 'beep').map(s => s.len);
    const silLens = segs.filter(s => s.type === 'silence').map(s => s.len);
    
    if (beepLens.length === 0) {
      throw new Error("未检测到有效的摩斯码信号");
    }

    // 严格按照摩尔斯电码标准时间间隔：
    // 1t = 点信号长度
    // - 点(·)：1t
    // - 划(-)：3t
    // - 符号间间隔：1t
    // - 字符间间隔：3t
    // - 单词间间隔：7t
    
    // 计算点长度：取最小的beep段作为基准1t
    beepLens.sort((a, b) => a - b);
    const dotLen = beepLens[0]; // 1t
    
    // 划长度为点的3倍 (3t)
    const dashLenThresh = dotLen * 3;

    // 静音归类：严格按照标准时间间隔
    silLens.sort((a, b) => a - b);
    
    // 符号间间隔：1t (使用最小的静音段作为参考)
    const symbolGapLen = Math.min(...silLens);
    
    // 字符间间隔：3t (标准要求)
    const charGapThresh = dotLen * 3;
    
    // 单词间间隔：7t (标准要求)
    const wordGapThresh = dotLen * 7;

    // 5. 还原摩斯字符串 - 改进版确保正确生成标准摩斯码格式
    let morse = '';
    let lastType = null;
    
    for (let seg of segs) {
      if (seg.type === 'beep') {
        // 添加点或划
        if (seg.len < dashLenThresh) {
          morse += '.';
        } else {
          morse += '-';
        }
        lastType = 'beep';
      } else {
        // 静音间隔处理
        if (lastType === 'beep') { // 只在声音后添加间隔
          if (seg.len < charGapThresh) {
            // 符号间间隔：不需要添加额外字符
          } else if (seg.len < wordGapThresh) {
            morse += ' '; // 字符间间隔
          } else {
            morse += ' / '; // 单词间间隔
          }
        }
        lastType = 'silence';
      }
    }
    
    // 清理并标准化最终的摩斯码字符串
    morse = morse.trim().replace(/\s+/g, ' ').replace(/\s\/\s/g, ' / ');

    // 6. 改进的摩斯码解码逻辑
    // 清理多余空格并标准化格式
    morse = morse.replace(/\s+/g, ' ').trim();
    
    // 为了调试，打印详细信息到控制台
    console.log('原始摩斯码字符串:', morse);
    console.log('摩斯反向映射表示例:', JSON.stringify({'.': morseReverseMap['.'], '-': morseReverseMap['-'], '.-': morseReverseMap['.-']}));
    
    // 正确处理摩斯码到文本的转换
    let tokens = morse.split(' ');
    let result = "";
    
    console.log('分割后的摩斯码标记:', tokens);
    
    for (let t of tokens) {
      if (t === '/' || t === '') {
        result += ' ';
        console.log('处理分隔符:', t, '添加空格');
      } else if (morseReverseMap[t]) {
        result += morseReverseMap[t];
        console.log('处理摩斯码:', t, '映射到:', morseReverseMap[t]);
      } else {
        // 如果没有找到精确匹配，尝试修复常见的解析错误
        let fixedToken = t;
        
        // 尝试修复可能的编码问题
        if (fixedToken.includes('\u00b7')) {
          fixedToken = fixedToken.replace(/\u00b7/g, '.');
        }
        
        // 再次尝试映射修复后的标记
        if (morseReverseMap[fixedToken]) {
          result += morseReverseMap[fixedToken];
          console.log('修复摩斯码:', t, '为:', fixedToken, '映射到:', morseReverseMap[fixedToken]);
        } else {
          result += '?';
          console.log('未识别的摩斯码:', t);
        }
      }
    }
    
    // 显示更详细的结果信息
    resultEl.textContent = "音频解码：" + result + "\n[原始摩斯码: " + morse + "]\n[转换后的文本: " + result + "]\n提示: 若解析不准确，可尝试调整敏感度滑块";
  } catch (err) {
    console.error('音频解析错误:', err);
    resultEl.textContent = "音频解析失败: " + (err.message || "未知错误");
  }
}

// 添加敏感度滑块事件监听
window.addEventListener('load', function() {
  const sensitivitySlider = document.getElementById('sensitivity');
  const sensitivityValue = document.getElementById('sensitivityValue');
  
  if (sensitivitySlider && sensitivityValue) {
    sensitivitySlider.addEventListener('input', function() {
      sensitivityValue.textContent = this.value;
    });
  }
});

</script>
