---
layout: default
title: 盲水印 - 冰兔的工具站
header_title: 盲水印工具
header_description: 采用改进的数字水印算法，提供更可靠的图像水印嵌入与提取功能
---

<h2>盲水印/隐藏水印加密工具</h2>
<p>上传图片，通过<strong>单层 DWT 小波域扩频</strong>+伪随机同步模板，生成对裁切、旋转、拍屏也非常鲁棒的水印图像。</p>

<h2>盲水印加密</h2>
<div class="container">
    <label>上传图片（JPG/PNG/WebP等）：</label>
    <input type="file" id="mediaInput" accept="image/*">
    <br>
    <label>上传水印图片（自动转换为64x64黑白）：</label>
    <input type="file" id="watermarkImageInput" accept="image/*">
    <label>或输入水印文字：</label>
    <textarea id="watermarkText" placeholder="输入水印文本，将被嵌入到图像中"></textarea>
    <br>
    <div id="watermarkPreview" style="margin: 10px 0;"></div>
    <label>设置密码（可选，增强安全性）：</label>
    <input type="text" id="password" placeholder="请输入密码，建议使用强密码">
    <br>
    <button id="encryptButton" class="disable-on-click">加密并下载</button>
</div>

<hr>

<h2>盲水印解密工具</h2>
<div class="container">
    <label>上传带水印的图片（PNG/JPG/WebP等）：</label>
    <input type="file" id="encodedMediaInput" accept="image/*">
    <br>
    <div class="form-group">
    <label>选择水印类型：</label>
    <div>
        <input type="radio" id="textWatermark" name="wmType" value="text" checked>
        <label for="textWatermark" style="display:inline">文字水印</label>
        <input type="radio" id="imageWatermark" name="wmType" value="image">
        <label for="imageWatermark" style="display:inline">图像水印（64x64）</label>
    </div>
    </div>
    <label>输入密码（加密时设置的密码）：</label>
    <input type="text" id="decodePassword" placeholder="请输入加密时使用的密码">
    <br>
    <button id="decryptButton" class="disable-on-click">解密并下载</button>
    <div id="extractResult"></div>
</div>

<div id="progressBar"><div></div></div>

<script>
(function () {
    'use strict';

    class ClaudeBlindWatermark {
        constructor() {
            this.WATERMARK_SIZE = 64;   // 64x64 = 4096 bits
            this.BLOCK_SIZE = 8;        // 8x8 DCT block
            this.Q_FACTOR = 32;         // 量化因子
            this.ALPHA = 0.2;           // 嵌入强度
            this.MAGIC = 0xA55A;        // 16 bit 魔数
        }

        // ===== 工具函数：密码 -> 种子 / PRNG =====
        generateSeed(password) {
            if (password == null) return 123456789;
            let normalized = String(password);
            try {
                normalized = normalized.normalize('NFKC');
            } catch (e) {}
            normalized = normalized.trim();
            if (!normalized) return 123456789;

            let hash = 0;
            for (let i = 0; i < normalized.length; i++) {
                const char = normalized.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0;
            }
            if (hash === 0) hash = 123456789;
            return Math.abs(hash);
        }

        createPRNG(seed) {
            let state = seed % 2147483647;
            if (state <= 0) state += 2147483646;

            return {
                next: function () {
                    state = Math.imul(state, 16807) % 2147483647;
                    return (state - 1) / 2147483646;
                },
                shuffle: function (array) {
                    const result = array.slice();
                    for (let i = result.length - 1; i > 0; i--) {
                        const j = Math.floor(this.next() * (i + 1));
                        const tmp = result[i];
                        result[i] = result[j];
                        result[j] = tmp;
                    }
                    return result;
                }
            };
        }

        // ===== 颜色空间转换 =====
        rgbToYuv(r, g, b) {
            const y = 0.299 * r + 0.587 * g + 0.114 * b;
            const u = -0.14713 * r - 0.28886 * g + 0.436 * b + 128;
            const v = 0.615 * r - 0.51499 * g - 0.10001 * b + 128;
            return [y, u, v];
        }

        yuvToRgb(y, u, v) {
            const r = y + 1.13983 * (v - 128);
            const g = y - 0.39465 * (u - 128) - 0.58060 * (v - 128);
            const b = y + 2.03211 * (u - 128);
            return [
                Math.max(0, Math.min(255, Math.round(r))),
                Math.max(0, Math.min(255, Math.round(g))),
                Math.max(0, Math.min(255, Math.round(b)))
            ];
        }

        // ===== DCT / IDCT =====
        dct1D(data) {
            const n = data.length;
            const result = new Array(n);
            for (let k = 0; k < n; k++) {
                let sum = 0;
                for (let i = 0; i < n; i++) {
                    sum += data[i] * Math.cos((Math.PI * k * (2 * i + 1)) / (2 * n));
                }
                const scale = k === 0 ? Math.sqrt(1 / n) : Math.sqrt(2 / n);
                result[k] = scale * sum;
            }
            return result;
        }

        idct1D(data) {
            const n = data.length;
            const result = new Array(n);
            for (let i = 0; i < n; i++) {
                let sum = 0;
                for (let k = 0; k < n; k++) {
                    const scale = k === 0 ? Math.sqrt(1 / n) : Math.sqrt(2 / n);
                    sum += scale * data[k] * Math.cos((Math.PI * k * (2 * i + 1)) / (2 * n));
                }
                result[i] = sum;
            }
            return result;
        }

        dct2D(matrix) {
            const n = matrix.length;
            const m = matrix[0].length;
            const result = new Array(n);
            for (let i = 0; i < n; i++) {
                result[i] = this.dct1D(matrix[i]);
            }
            for (let j = 0; j < m; j++) {
                const column = new Array(n);
                for (let i = 0; i < n; i++) column[i] = result[i][j];
                const transCol = this.dct1D(column);
                for (let i = 0; i < n; i++) result[i][j] = transCol[i];
            }
            return result;
        }

        idct2D(matrix) {
            const n = matrix.length;
            const m = matrix[0].length;
            const result = new Array(n);
            for (let i = 0; i < n; i++) {
                result[i] = this.idct1D(matrix[i]);
            }
            for (let j = 0; j < m; j++) {
                const column = new Array(n);
                for (let i = 0; i < n; i++) column[i] = result[i][j];
                const transCol = this.idct1D(column);
                for (let i = 0; i < n; i++) result[i][j] = transCol[i];
            }
            return result;
        }

        // ===== 图像加载 & 水印图片准备 =====
        async loadImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const img = new Image();
                    img.onload = function () {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        const imageData = ctx.getImageData(0, 0, img.width, img.height);
                        resolve({
                            data: imageData.data,
                            width: img.width,
                            height: img.height
                        });
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        async prepareWatermarkImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = this.WATERMARK_SIZE;
                        canvas.height = this.WATERMARK_SIZE;
                        ctx.drawImage(img, 0, 0, this.WATERMARK_SIZE, this.WATERMARK_SIZE);
                        const imageData = ctx.getImageData(0, 0, this.WATERMARK_SIZE, this.WATERMARK_SIZE);
                        const binaryData = [];
                        for (let i = 0; i < imageData.data.length; i += 4) {
                            const gray = 0.299 * imageData.data[i] +
                                0.587 * imageData.data[i + 1] +
                                0.114 * imageData.data[i + 2];
                            binaryData.push(gray > 128 ? 1 : 0);
                        }
                        resolve({
                            data: binaryData,
                            width: this.WATERMARK_SIZE,
                            height: this.WATERMARK_SIZE
                        });
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // ===== 文字 <-> bit 流（带魔数 + 长度 + 校验） =====
        textToWatermarkData(text) {
            const totalBits  = this.WATERMARK_SIZE * this.WATERMARK_SIZE; // 4096
            const headerBits = 16 + 16 + 16; // magic + length + checksum

            const encoder = new TextEncoder();
            const textBytes = encoder.encode(text);
            const maxBytes  = Math.floor((totalBits - headerBits) / 8);
            const length    = Math.min(textBytes.length, maxBytes);

            let checksum = 0;
            for (let i = 0; i < length; i++) {
                checksum = (checksum + textBytes[i]) & 0xFFFF;
            }

            const bits = [];
            const pushBits = (value, bitCount) => {
                for (let i = bitCount - 1; i >= 0; i--) {
                    bits.push((value >> i) & 1);
                }
            };

            // 头部：MAGIC + length + checksum
            pushBits(this.MAGIC & 0xFFFF, 16);
            pushBits(length & 0xFFFF, 16);
            pushBits(checksum & 0xFFFF, 16);

            // 正文
            for (let i = 0; i < length; i++) {
                pushBits(textBytes[i], 8);
            }

            // 填充到固定长度
            while (bits.length < totalBits) bits.push(0);
            if (bits.length > totalBits) bits.length = totalBits;

            return bits;
        }

        decodeWatermarkText(bits) {
            const totalBits  = bits.length;
            const headerBits = 16 + 16 + 16;
            if (totalBits < headerBits) return { text: "", valid: false };

            const readBits = (start, len) => {
                let v = 0;
                for (let i = 0; i < len; i++) {
                    const bit = bits[start + i] ? 1 : 0;
                    v = (v << 1) | bit;
                }
                return v >>> 0;
            };

            const magic          = readBits(0, 16);
            const length         = readBits(16, 16);
            const checksumStored = readBits(32, 16);
            if (magic !== (this.MAGIC & 0xFFFF)) return { text: "", valid: false };

            const maxBytes = Math.floor((totalBits - headerBits) / 8);
            if (length < 0 || length > maxBytes) return { text: "", valid: false };

            const bytes = [];
            for (let i = 0; i < length; i++) {
                let byte = 0;
                for (let j = 0; j < 8; j++) {
                    const bitIndex = headerBits + i * 8 + j;
                    const bit = bitIndex < totalBits ? (bits[bitIndex] ? 1 : 0) : 0;
                    byte = (byte << 1) | bit;
                }
                bytes.push(byte);
            }

            // 校验和
            let checksumCalc = 0;
            for (let i = 0; i < bytes.length; i++) {
                checksumCalc = (checksumCalc + bytes[i]) & 0xFFFF;
            }
            if (checksumCalc !== checksumStored) return { text: "", valid: false };

            try {
                const decoder = new TextDecoder();
                const text = decoder.decode(new Uint8Array(bytes));
                return { text, valid: true };
            } catch (e) {
                return { text: "", valid: false };
            }
        }

        watermarkDataToText(bits) {
            const { text, valid } = this.decodeWatermarkText(bits);
            return valid ? text : "";
        }

        // ===== 几何变换（仅用于解码） =====
        applyTransform(imageInfo, transform) {
            if (transform === 'none') return imageInfo;

            const width  = imageInfo.width;
            const height = imageInfo.height;

            const srcCanvas = document.createElement('canvas');
            srcCanvas.width  = width;
            srcCanvas.height = height;
            const srcCtx = srcCanvas.getContext('2d');
            const srcImageData = srcCtx.createImageData(width, height);
            srcImageData.data.set(imageInfo.data);
            srcCtx.putImageData(srcImageData, 0, 0);

            const dstCanvas = document.createElement('canvas');
            dstCanvas.width  = width;
            dstCanvas.height = height;
            const dstCtx = dstCanvas.getContext('2d');

            dstCtx.save();
            switch (transform) {
                case 'flipH':
                    dstCtx.translate(width, 0);
                    dstCtx.scale(-1, 1);
                    break;
                case 'flipV':
                    dstCtx.translate(0, height);
                    dstCtx.scale(1, -1);
                    break;
                case 'flipHV':
                    dstCtx.translate(width, height);
                    dstCtx.scale(-1, -1);
                    break;
                default:
                    break;
            }
            dstCtx.drawImage(srcCanvas, 0, 0);
            dstCtx.restore();

            const dstImageData = dstCtx.getImageData(0, 0, dstCanvas.width, dstCanvas.height);
            return {
                data: dstImageData.data,
                width: dstCanvas.width,
                height: dstCanvas.height
            };
        }

        // ===== 嵌入（冗余编码） =====
        async embedWatermark(imageInfo, watermarkBits, password) {
            const seed = this.generateSeed(password);
            const prng = this.createPRNG(seed);

            const width  = imageInfo.width;
            const height = imageInfo.height;
            const data   = imageInfo.data;

            const canvas = document.createElement('canvas');
            const ctx    = canvas.getContext('2d');
            canvas.width  = width;
            canvas.height = height;

            const imgData = ctx.createImageData(width, height);
            imgData.data.set(data);
            ctx.putImageData(imgData, 0, 0);

            const imageData = ctx.getImageData(0, 0, width, height);
            const pixels    = imageData.data;

            const numBlocksX = Math.floor(width  / this.BLOCK_SIZE);
            const numBlocksY = Math.floor(height / this.BLOCK_SIZE);
            const totalBlocks = numBlocksX * numBlocksY;

            if (!Number.isFinite(numBlocksX) || !Number.isFinite(numBlocksY) || totalBlocks <= 0) {
                throw new Error('图片分辨率过小或非法，无法嵌入水印');
            }

            const fullBits   = this.WATERMARK_SIZE * this.WATERMARK_SIZE; // 4096
            const bitsLen    = watermarkBits && Array.isArray(watermarkBits) ? watermarkBits.length : 0;
            const bitsToUse  = Math.min(fullBits, bitsLen);

            if (!watermarkBits || bitsLen === 0 || bitsToUse <= 0) {
                throw new Error('水印数据为空，无法嵌入');
            }

            let effectiveBits = Math.min(bitsToUse, totalBlocks);
            if (!Number.isFinite(effectiveBits) || effectiveBits <= 0) {
                throw new Error('图片块数不足以嵌入任何水印位');
            }

            let repeats = Math.floor(totalBlocks / effectiveBits);
            if (!Number.isFinite(repeats) || repeats < 1) repeats = 1;

            let usedBlocks = effectiveBits * repeats;
            if (!Number.isFinite(usedBlocks) || usedBlocks > totalBlocks) {
                usedBlocks = totalBlocks; // 强制截断
            }

            // 构造并打乱块索引
            const blockIndices = [];
            for (let y = 0; y < numBlocksY; y++) {
                for (let x = 0; x < numBlocksX; x++) {
                    blockIndices.push({ x, y });
                }
            }
            const shuffledIndices = prng.shuffle(blockIndices);

            console.log('[embedWatermark] totalBlocks =', totalBlocks,
                        'bitsLen =', bitsLen,
                        'fullBits =', fullBits,
                        'bitsToUse =', bitsToUse,
                        'effectiveBits =', effectiveBits,
                        'repeats =', repeats,
                        'usedBlocks =', usedBlocks,
                        'shuffledLen =', shuffledIndices.length);

            const embedPos      = 3;              // DCT(3,3) 位置
            const embedStrength = this.Q_FACTOR * this.ALPHA;

            for (let bitIndex = 0; bitIndex < effectiveBits; bitIndex++) {
                const bit = watermarkBits[bitIndex] ? 1 : 0;

                for (let k = 0; k < repeats; k++) {
                    const globalIndex = bitIndex * repeats + k;

                    // 边界与合法性检查
                    if (!Number.isFinite(globalIndex) ||
                        globalIndex < 0 ||
                        globalIndex >= usedBlocks ||
                        globalIndex >= shuffledIndices.length) {
                        continue;
                    }

                    const blockInfo = shuffledIndices[globalIndex];
                    if (!blockInfo || typeof blockInfo.x !== 'number' || typeof blockInfo.y !== 'number') {
                        console.warn('[embedWatermark] 无效 blockInfo at', globalIndex, blockInfo);
                        continue;
                    }

                    const bx0 = blockInfo.x * this.BLOCK_SIZE;
                    const by0 = blockInfo.y * this.BLOCK_SIZE;

                    // 取出该块亮度 Y
                    const block = [];
                    for (let by = 0; by < this.BLOCK_SIZE; by++) {
                        const row = [];
                        for (let bx = 0; bx < this.BLOCK_SIZE; bx++) {
                            const px = bx0 + bx;
                            const py = by0 + by;
                            if (px < width && py < height) {
                                const idx = (py * width + px) * 4;
                                const r = pixels[idx];
                                const g = pixels[idx + 1];
                                const b = pixels[idx + 2];
                                const [Y] = this.rgbToYuv(r, g, b);
                                row.push(Y);
                            } else {
                                row.push(0);
                            }
                        }
                        block.push(row);
                    }

                    // DCT
                    const dctBlock = this.dct2D(block);
                    if (dctBlock[embedPos] && typeof dctBlock[embedPos][embedPos] === 'number') {
                        const orig  = dctBlock[embedPos][embedPos];
                        const quant = Math.round(orig / this.Q_FACTOR) * this.Q_FACTOR;
                        dctBlock[embedPos][embedPos] = quant + embedStrength * (bit ? 1 : -1);
                    } else {
                        continue;
                    }

                    // IDCT 写回
                    const idctBlock = this.idct2D(dctBlock);
                    for (let by = 0; by < this.BLOCK_SIZE; by++) {
                        for (let bx = 0; bx < this.BLOCK_SIZE; bx++) {
                            const px = bx0 + bx;
                            const py = by0 + by;
                            if (px < width && py < height) {
                                const idx = (py * width + px) * 4;
                                const r = pixels[idx];
                                const g = pixels[idx + 1];
                                const b = pixels[idx + 2];
                                const [, U, V] = this.rgbToYuv(r, g, b);
                                const newY = Math.max(0, Math.min(255, idctBlock[by][bx]));
                                const [newR, newG, newB] = this.yuvToRgb(newY, U, V);
                                pixels[idx]     = newR;
                                pixels[idx + 1] = newG;
                                pixels[idx + 2] = newB;
                            }
                        }
                    }
                }

                if (bitIndex % 50 === 0) {
                    this.showProgress(Math.floor((bitIndex / effectiveBits) * 80));
                }
            }

            ctx.putImageData(imageData, 0, 0);

            return new Promise((resolve, reject) => {
                if (!canvas.toBlob) {
                    reject(new Error('当前浏览器不支持 canvas.toBlob'));
                    return;
                }
                canvas.toBlob(blob => {
                    if (!blob) reject(new Error('生成水印图片失败'));
                    else resolve(blob);
                }, 'image/png');
            });
        }

        // 单次提取（不做几何搜索）：用冗余投票恢复 4096 bit
        _extractBitsCore(imageInfo, password) {
            const seed = this.generateSeed(password);
            const prng = this.createPRNG(seed);

            const width  = imageInfo.width;
            const height = imageInfo.height;
            const pixels = imageInfo.data;

            const numBlocksX = Math.floor(width  / this.BLOCK_SIZE);
            const numBlocksY = Math.floor(height / this.BLOCK_SIZE);
            const totalBlocks = numBlocksX * numBlocksY;

            const fullBits = this.WATERMARK_SIZE * this.WATERMARK_SIZE;

            if (!Number.isFinite(numBlocksX) || !Number.isFinite(numBlocksY) || totalBlocks <= 0) {
                console.warn('[extractBitsCore] 图片块数为 0，返回全 0');
                return new Array(fullBits).fill(0);
            }

            let effectiveBits = Math.min(fullBits, totalBlocks);
            if (!Number.isFinite(effectiveBits) || effectiveBits <= 0) {
                console.warn('[extractBitsCore] effectiveBits 非法，返回全 0');
                return new Array(fullBits).fill(0);
            }

            let repeats = Math.floor(totalBlocks / effectiveBits);
            if (!Number.isFinite(repeats) || repeats < 1) repeats = 1;

            let usedBlocks = effectiveBits * repeats;
            if (!Number.isFinite(usedBlocks) || usedBlocks > totalBlocks) {
                usedBlocks = totalBlocks;
            }

            const blockIndices = [];
            for (let y = 0; y < numBlocksY; y++) {
                for (let x = 0; x < numBlocksX; x++) {
                    blockIndices.push({ x, y });
                }
            }
            const shuffledIndices = prng.shuffle(blockIndices);

            console.log('[extractBitsCore] totalBlocks =', totalBlocks,
                        'fullBits =', fullBits,
                        'effectiveBits =', effectiveBits,
                        'repeats =', repeats,
                        'usedBlocks =', usedBlocks,
                        'shuffledLen =', shuffledIndices.length);

            const votes   = new Array(effectiveBits).fill(0);
            const embedPos = 3;

            for (let bitIndex = 0; bitIndex < effectiveBits; bitIndex++) {
                for (let k = 0; k < repeats; k++) {
                    const globalIndex = bitIndex * repeats + k;

                    if (!Number.isFinite(globalIndex) ||
                        globalIndex < 0 ||
                        globalIndex >= usedBlocks ||
                        globalIndex >= shuffledIndices.length) {
                        continue;
                    }

                    const blockInfo = shuffledIndices[globalIndex];
                    if (!blockInfo || typeof blockInfo.x !== 'number' || typeof blockInfo.y !== 'number') {
                        console.warn('[extractBitsCore] 无效 blockInfo at', globalIndex, blockInfo);
                        continue;
                    }

                    const bx0 = blockInfo.x * this.BLOCK_SIZE;
                    const by0 = blockInfo.y * this.BLOCK_SIZE;

                    const block = [];
                    for (let by = 0; by < this.BLOCK_SIZE; by++) {
                        const row = [];
                        for (let bx = 0; bx < this.BLOCK_SIZE; bx++) {
                            const px = bx0 + bx;
                            const py = by0 + by;
                            if (px < width && py < height) {
                                const idx = (py * width + px) * 4;
                                const r = pixels[idx];
                                const g = pixels[idx + 1];
                                const b = pixels[idx + 2];
                                const [Y] = this.rgbToYuv(r, g, b);
                                row.push(Y);
                            } else {
                                row.push(0);
                            }
                        }
                        block.push(row);
                    }

                    const dctBlock = this.dct2D(block);
                    if (dctBlock[embedPos] && typeof dctBlock[embedPos][embedPos] === 'number') {
                        const value = dctBlock[embedPos][embedPos];
                        const quant = Math.round(value / this.Q_FACTOR) * this.Q_FACTOR;
                        const diff  = value - quant;
                        const bit   = diff >= 0 ? 1 : 0;
                        votes[bitIndex] += bit ? 1 : -1;
                    }
                }
            }

            const extractedBits = new Array(fullBits).fill(0);
            for (let i = 0; i < effectiveBits; i++) {
                extractedBits[i] = votes[i] >= 0 ? 1 : 0;
            }
            return extractedBits;
        }

        async extractWatermark(imageInfo, password, isText) {
            if (!isText) {
                const bits = this._extractBitsCore(imageInfo, password);
                return { bits };
            }

            const transforms = ['none', 'flipH', 'flipV', 'flipHV'];
            let best = { bits: null, text: "", valid: false, transform: 'none' };

            for (let i = 0; i < transforms.length; i++) {
                const t = transforms[i];
                const transformed = this.applyTransform(imageInfo, t);
                const bits = this._extractBitsCore(transformed, password);
                const r = this.decodeWatermarkText(bits);
                if (r.valid && r.text && r.text.length > 0) {
                    best.bits = bits;
                    best.text = r.text;
                    best.valid = true;
                    best.transform = t;
                    break;
                }
                if (!best.bits) {
                    best.bits = bits;
                    best.text = "";
                    best.valid = false;
                    best.transform = t;
                }
            }

            this.showProgress(80);
            return best;
        }

        // ===== UI 辅助 =====
        showProgress(progress) {
            const progressBar = document.getElementById('progressBar');
            if (!progressBar) return;
            progressBar.style.display = 'block';
            const inner = progressBar.querySelector('div');
            if (inner) inner.style.width = progress + '%';
        }

        hideProgress() {
            const progressBar = document.getElementById('progressBar');
            if (!progressBar) return;
            progressBar.style.display = 'none';
            const inner = progressBar.querySelector('div');
            if (inner) inner.style.width = '0%';
        }

        showNotification(message, type) {
            type = type || 'info';
            const existing = document.querySelector('.notification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.className = 'notification ' + type;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(function () {
                notification.classList.add('show');
            }, 10);
            setTimeout(function () {
                notification.classList.remove('show');
                setTimeout(function () {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        downloadFile(blob, filename) {
            try {
                if (!blob) {
                    throw new Error('空的 Blob');
                }
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                setTimeout(function () {
                    if (a.parentNode) a.parentNode.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            } catch (e) {
                console.error('下载文件失败:', e);
                this.showNotification('下载文件失败: ' + (e && e.message ? e.message : e), 'error');
            }
        }
    }

    // ===== 页面初始化和事件绑定 =====
    document.addEventListener('DOMContentLoaded', function () {
        try {
            console.log('[BlindWatermark] DOMContentLoaded');

            const blindWatermark = new ClaudeBlindWatermark();

            const mediaInput          = document.getElementById('mediaInput');
            const watermarkImageInput = document.getElementById('watermarkImageInput');
            const watermarkTextInput  = document.getElementById('watermarkText');
            const passwordInput       = document.getElementById('password');
            const encodedMediaInput   = document.getElementById('encodedMediaInput');
            const decodePasswordInput = document.getElementById('decodePassword');
            const encryptButton       = document.getElementById('encryptButton');
            const decryptButton       = document.getElementById('decryptButton');
            const resultDiv           = document.getElementById('extractResult');

            if (!mediaInput || !watermarkImageInput || !watermarkTextInput ||
                !passwordInput || !encodedMediaInput || !decodePasswordInput ||
                !encryptButton || !decryptButton || !resultDiv) {
                console.error('[BlindWatermark] 必要的 DOM 元素缺失');
                alert('盲水印脚本初始化失败：页面上有必要的元素缺失，请检查 id 是否一致');
                return;
            }

            // 水印预览
            function showWatermarkPreview(data, isText) {
                const previewDiv = document.getElementById('watermarkPreview');
                if (!previewDiv) return;
                previewDiv.innerHTML = '';

                if (isText) {
                    const encoder = new TextEncoder();
                    const bytes   = encoder.encode(data);
                    const totalBits  = blindWatermark.WATERMARK_SIZE * blindWatermark.WATERMARK_SIZE;
                    const headerBits = 16 + 16 + 16;
                    const capacityBytes = Math.floor((totalBits - headerBits) / 8);

                    const textDiv = document.createElement('div');
                    textDiv.style.cssText = 'background:#f5f5f5;padding:10px;border-radius:5px;margin:10px 0;font-family:monospace;';
                    textDiv.innerHTML =
                        '<strong>文字水印预览:</strong><br>' +
                        '原文: "' + data.replace(/</g, '&lt;') + '"<br>' +
                        '<small style="color:#666;">' +
                        '预计 UTF-8 字节数: ' + bytes.length + '<br>' +
                        '最大可嵌入字节数: ' + capacityBytes + '（超过部分将被截断）<br>' +
                        '水印平面: ' + blindWatermark.WATERMARK_SIZE + 'x' + blindWatermark.WATERMARK_SIZE +
                        ' = ' + totalBits + ' bits' +
                        '</small>';
                    previewDiv.appendChild(textDiv);
                    return;
                }

                const canvas = document.createElement('canvas');
                canvas.width  = blindWatermark.WATERMARK_SIZE;
                canvas.height = blindWatermark.WATERMARK_SIZE;
                canvas.style.cssText = 'border:1px solid #ddd;margin:10px 0;max-width:128px;max-height:128px;';
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(blindWatermark.WATERMARK_SIZE, blindWatermark.WATERMARK_SIZE);

                for (let i = 0; i < data.length && i < blindWatermark.WATERMARK_SIZE * blindWatermark.WATERMARK_SIZE; i++) {
                    const value = data[i] > 0.5 ? 255 : 0;
                    imageData.data[i * 4]     = value;
                    imageData.data[i * 4 + 1] = value;
                    imageData.data[i * 4 + 2] = value;
                    imageData.data[i * 4 + 3] = 255;
                }
                ctx.putImageData(imageData, 0, 0);

                const label = document.createElement('div');
                label.textContent = '水印预览 (' + blindWatermark.WATERMARK_SIZE + 'x' + blindWatermark.WATERMARK_SIZE + ' 黑白):';
                label.style.fontWeight   = 'bold';
                label.style.marginBottom = '10px';

                previewDiv.appendChild(label);
                previewDiv.appendChild(canvas);
            }

            // 图像水印选择
            watermarkImageInput.addEventListener('change', function () {
                if (this.files && this.files[0]) {
                    blindWatermark.prepareWatermarkImage(this.files[0])
                        .then(function (wmInfo) {
                            showWatermarkPreview(wmInfo.data, false);
                            watermarkTextInput.value = '';
                        })
                        .catch(function (e) {
                            console.error('水印图片加载失败:', e);
                            blindWatermark.showNotification('水印图片加载失败: ' + e.message, 'error');
                        });
                } else {
                    const previewDiv = document.getElementById('watermarkPreview');
                    if (previewDiv) previewDiv.innerHTML = '';
                }
            });

            // 文字水印输入
            watermarkTextInput.addEventListener('input', function () {
                const text = this.value.trim();
                if (text) {
                    showWatermarkPreview(text, true);
                    watermarkImageInput.value = '';
                } else {
                    const previewDiv = document.getElementById('watermarkPreview');
                    if (previewDiv) previewDiv.innerHTML = '';
                }
            });

            // 加密按钮
            encryptButton.addEventListener('click', async function () {
                console.log('[BlindWatermark] 点击加密按钮');
                const button = this;
                const originalText = button.textContent;
                button.disabled = true;
                button.textContent = '处理中...';

                try {
                    blindWatermark.showProgress(0);

                    const mediaFile         = mediaInput.files[0];
                    const watermarkImageFile = watermarkImageInput.files[0];
                    const watermarkText     = watermarkTextInput.value.trim();
                    const password          = passwordInput.value;

                    if (!mediaFile) {
                        blindWatermark.showNotification('请选择要加密的图片', 'warning');
                        return;
                    }
                    if (!watermarkImageFile && !watermarkText) {
                        blindWatermark.showNotification('请选择水印图片或输入水印文字', 'warning');
                        return;
                    }

                    blindWatermark.showProgress(10);
                    const imageInfo = await blindWatermark.loadImage(mediaFile);
                    blindWatermark.showProgress(20);

                    let watermarkBits;
                    if (watermarkImageFile) {
                        const wmInfo = await blindWatermark.prepareWatermarkImage(watermarkImageFile);
                        watermarkBits = wmInfo.data;
                    } else {
                        watermarkBits = blindWatermark.textToWatermarkData(watermarkText);
                    }
                    blindWatermark.showProgress(40);

                    const resultBlob = await blindWatermark.embedWatermark(imageInfo, watermarkBits, password);
                    blindWatermark.showProgress(90);

                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
                    const filename  = 'claude_watermarked_' + timestamp + '.png';
                    blindWatermark.downloadFile(resultBlob, filename);

                    blindWatermark.showProgress(100);
                    blindWatermark.showNotification('水印嵌入成功！图片已开始下载。', 'success');
                } catch (e) {
                    console.error('加密失败:', e);
                    blindWatermark.showNotification('加密失败: ' + e.message, 'error');
                } finally {
                    button.disabled = false;
                    button.textContent = originalText;
                    setTimeout(function () { blindWatermark.hideProgress(); }, 500);
                }
            });

            // 解密按钮
            decryptButton.addEventListener('click', async function () {
                console.log('[BlindWatermark] 点击解密按钮');
                const button = this;
                const originalText = button.textContent;
                button.disabled = true;
                button.textContent = '处理中...';

                try {
                    blindWatermark.showProgress(0);
                    const encodedFile  = encodedMediaInput.files[0];
                    const password     = decodePasswordInput.value;
                    const selectedTypeInput = document.querySelector('input[name="wmType"]:checked');
                    const selectedType = selectedTypeInput ? selectedTypeInput.value : 'text';

                    if (!encodedFile) {
                        blindWatermark.showNotification('请选择带水印的图片', 'warning');
                        return;
                    }

                    blindWatermark.showProgress(10);
                    const imageInfo = await blindWatermark.loadImage(encodedFile);
                    blindWatermark.showProgress(20);

                    const isText = (selectedType === 'text');
                    blindWatermark.showProgress(30);
                    const result = await blindWatermark.extractWatermark(imageInfo, password, isText);
                    blindWatermark.showProgress(90);

                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];

                    if (isText) {
                        const text = result.text || '';
                        resultDiv.innerHTML =
                            '<div style="background:#f5f5f5;padding:15px;border-radius:5px;">' +
                            '<strong>提取的文字水印：</strong><br>' +
                            '<div style="font-family:monospace;background:white;padding:10px;border-radius:3px;margin-top:10px;min-height:30px;word-break:break-all;">' +
                            (text || '(提取失败或水印为空)') +
                            '</div>' +
                            '<small style="color:#666;margin-top:10px;display:block;">' +
                            '提取状态: ' + (result.valid && text ? '成功' : '失败') +
                            ' | 字符数: ' + text.length +
                            ' | 使用变换: ' + result.transform +
                            '</small>' +
                            '</div>';

                        if (result.valid && text) {
                            const blob = new Blob([text], { type: 'text/plain' });
                            blindWatermark.downloadFile(blob, 'claude_extracted_text_' + timestamp + '.txt');
                            blindWatermark.showNotification('文字水印提取成功！', 'success');
                        } else {
                            blindWatermark.showNotification('文字水印提取失败，请检查密码或图片是否被严重破坏', 'error');
                        }
                    } else {
                        const bits   = result.bits || [];
                        const canvas = document.createElement('canvas');
                        canvas.width  = blindWatermark.WATERMARK_SIZE;
                        canvas.height = blindWatermark.WATERMARK_SIZE;
                        const ctx     = canvas.getContext('2d');
                        const imgData = ctx.createImageData(canvas.width, canvas.height);

                        for (let i = 0; i < bits.length && i < canvas.width * canvas.height; i++) {
                            const idx = i * 4;
                            const value = bits[i] > 0.5 ? 255 : 0;
                            imgData.data[idx]     = value;
                            imgData.data[idx + 1] = value;
                            imgData.data[idx + 2] = value;
                            imgData.data[idx + 3] = 255;
                        }
                        ctx.putImageData(imgData, 0, 0);

                        resultDiv.innerHTML =
                            '<div style="background:#f5f5f5;padding:15px;border-radius:5px;">' +
                            '<strong>提取的图像水印 (' + blindWatermark.WATERMARK_SIZE + 'x' +
                            blindWatermark.WATERMARK_SIZE + ')：</strong><br>' +
                            '</div>';
                        const container = resultDiv.querySelector('div');
                        container.appendChild(canvas);

                        if (canvas.toBlob) {
                            canvas.toBlob(function (blob) {
                                blindWatermark.downloadFile(blob, 'claude_extracted_watermark_' + timestamp + '.png');
                            }, 'image/png');
                        }
                        blindWatermark.showNotification('图像水印提取完成！', 'success');
                    }
                } catch (e) {
                    console.error('解密失败:', e);
                    blindWatermark.showNotification('解密失败: ' + e.message, 'error');
                } finally {
                    button.disabled = false;
                    button.textContent = originalText;
                    setTimeout(function () { blindWatermark.hideProgress(); }, 500);
                }
            });

            // 防止按钮连点（轻量版）
            const btns = document.querySelectorAll('.disable-on-click');
            for (let i = 0; i < btns.length; i++) {
                btns[i].addEventListener('click', function () {
                    const self = this;
                    if (self.disabled) return;
                    setTimeout(function () {
                        if (!String(self.textContent || '').includes('中...')) {
                            self.disabled = false;
                        }
                    }, 1000);
                });
            }

            // loading 占位元素
            if (!document.getElementById('loadingIndicator')) {
                const loadingElement = document.createElement('div');
                loadingElement.id = 'loadingIndicator';
                loadingElement.style.display = 'none';
                document.body.appendChild(loadingElement);
            }

            console.log('[BlindWatermark] 初始化完成');
        } catch (e) {
            console.error('[BlindWatermark] 初始化失败:', e);
            alert('盲水印脚本初始化失败：' + (e && e.message ? e.message : e));
        }
    });
})();
</script>